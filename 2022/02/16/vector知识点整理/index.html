<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="概述本文整理了一些最近复习vector的内容时的一些重点知识，主要包括vector的底层实现、vector增加以及删除元素的实现以及效率、vector的迭代器等内容。">
<meta property="og:type" content="article">
<meta property="og:title" content="vector知识点整理">
<meta property="og:url" content="http://example.com/2022/02/16/vector%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="Now or never">
<meta property="og:description" content="概述本文整理了一些最近复习vector的内容时的一些重点知识，主要包括vector的底层实现、vector增加以及删除元素的实现以及效率、vector的迭代器等内容。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/all_images/vector知识点整理/1.png">
<meta property="og:image" content="http://example.com/all_images/vector知识点整理/2.png">
<meta property="og:image" content="http://example.com/all_images/vector知识点整理/4.png">
<meta property="og:image" content="http://example.com/all_images/vector知识点整理/3.png">
<meta property="og:image" content="http://example.com/all_images/vector知识点整理/5.png">
<meta property="og:image" content="http://example.com/all_images/vector知识点整理/6.png">
<meta property="article:published_time" content="2022-02-16T07:01:24.000Z">
<meta property="article:modified_time" content="2022-03-06T16:11:45.947Z">
<meta property="article:author" content="vitalemonate">
<meta property="article:tag" content="STL">
<meta property="article:tag" content="vector">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/all_images/vector知识点整理/1.png">

<link rel="canonical" href="http://example.com/2022/02/16/vector%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>vector知识点整理 | Now or never</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Now or never</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">勿在浮沙筑高台</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/16/vector%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="vitalemonate">
      <meta itemprop="description" content="Ideas don't come out of thin air">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Now or never">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          vector知识点整理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-16 15:01:24" itemprop="dateCreated datePublished" datetime="2022-02-16T15:01:24+08:00">2022-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-07 00:11:45" itemprop="dateModified" datetime="2022-03-07T00:11:45+08:00">2022-03-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/16/vector%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/16/vector%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文整理了一些最近复习vector的内容时的一些重点知识，主要包括vector的底层实现、vector增加以及删除元素的实现以及效率、vector的迭代器等内容。<br><span id="more"></span></p>
<h1 id="vector的底层实现"><a href="#vector的底层实现" class="headerlink" title="vector的底层实现"></a>vector的底层实现</h1><p>vector容器本质上是个<strong>动态数组</strong>，其底层实现可以总结为：<strong>动态数组、三根指针、双倍增长</strong>。</p>
<p>C++11标准前，vector的底层实现比较清晰明了，C++11标准后出于<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/ebo"><strong>空基类优化</strong></a>的考虑，对vector类的继承关系进行了调整，使得vector的实现看起来比较复杂，但是本质的底层实现没有改变，都是通过内部的<strong>三根指针start, finish, end_of_storage</strong>以及<strong>STL的分配器allocator</strong>来完成内存的分配以及释放操作，所以一个vector对象本身的大小就是这3个指针，在32位的系统上是12个字节。</p>
<h2 id="C-11前vector的实现（gcc-2-9）"><a href="#C-11前vector的实现（gcc-2-9）" class="headerlink" title="C++11前vector的实现（gcc 2.9）"></a>C++11前vector的实现（gcc 2.9）</h2><p>start指向存储的数据的起始位置，对应begin()，finish指向数据的结束的下一个位置，对应end()，end_of_storage指向<strong>可使用空间</strong>的结束位置</p>
<div align="center">
<img src="/all_images/vector知识点整理/1.png">
</div>

<h2 id="C-11后vector的实现（gcc-4-9）"><a href="#C-11后vector的实现（gcc-4-9）" class="headerlink" title="C++11后vector的实现（gcc 4.9）"></a>C++11后vector的实现（gcc 4.9）</h2><div align="center">
<img src="/all_images/vector知识点整理/2.png">
</div>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">Vector_base</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">// 这里通过rebind&lt;_Tp&gt;::other来获得内存分配器</span></span><br><span class="line">    <span class="comment">// 参考https://www.bookstack.cn/read/CPlusPlusThings/ca7ffa122ab5f274.md</span></span><br><span class="line">    <span class="comment">// 这里等价于 typedef allocator&lt;_Tp&gt; _Tp_alloc_type，推导见https://blog.csdn.net/guangcheng0312q/article/details/102549710#t2</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::<span class="keyword">template</span></span><br><span class="line">        rebind&lt;_Tp&gt;::other _Tp_alloc_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt;::pointer</span><br><span class="line">         pointer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C++11后新增加的类，和_Vector_base是has-a的关系</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">Vector_impl</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> _Tp_alloc_type</span><br><span class="line">    &#123;</span><br><span class="line">      pointer _M_start;</span><br><span class="line">      pointer _M_finish;</span><br><span class="line">      pointer _M_end_of_storage;</span><br><span class="line">      ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">typedef</span> _Alloc allocator_type;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      _Vector_impl _M_impl;</span><br><span class="line"></span><br><span class="line">    pointer</span><br><span class="line">    _M_allocate(<span class="keyword">size_t</span> __n)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">typedef</span> __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt; _Tr;</span><br><span class="line">      <span class="keyword">return</span> __n != <span class="number">0</span> ? _Tr::<span class="built_in">allocate</span>(_M_impl, __n) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span></span><br><span class="line">    _M_deallocate(pointer __p, <span class="keyword">size_t</span> __n)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">typedef</span> __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt; _Tr;</span><br><span class="line">      <span class="keyword">if</span> (__p)</span><br><span class="line">      _Tr::<span class="built_in">deallocate</span>(_M_impl, __p, __n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">void</span></span><br><span class="line">    _M_create_storage(<span class="keyword">size_t</span> __n)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;_M_impl._M_start = <span class="keyword">this</span>-&gt;_M_allocate(__n);</span><br><span class="line">      <span class="keyword">this</span>-&gt;_M_impl._M_finish = <span class="keyword">this</span>-&gt;_M_impl._M_start;</span><br><span class="line">      <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage = <span class="keyword">this</span>-&gt;_M_impl._M_start + __n;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">  class vector : <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;</span><br><span class="line">&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h1><p>vector增加元素主要有四个函数，push_back，insert，emplace_back和emplace，其中后两者是C++11标准中新增加的内容</p>
<h2 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h2><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>C++11前，push_back只有常量引用版本，在C++11后，增加了右值引用的重载版本，实际调用的是emplace_back。常量引用版本的push_back在可用空间还没有用完时，把元素直接插入_M_finish所指向的位置，如果已经用完，则调且辅助函数_M_insert_aux或者_M_emplace_back_aux（C++11后）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; __x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_M_impl._M_finish != <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage)</span><br><span class="line">  &#123;</span><br><span class="line">    _Alloc_traits::<span class="built_in">construct</span>(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">                           __x);</span><br><span class="line">     ++<span class="keyword">this</span>-&gt;_M_impl._M_finish;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">    _M_emplace_back_aux(__x);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _M_insert_aux(<span class="built_in">end</span>(), __x);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(value_type&amp;&amp; __x)</span></span>&#123;</span><br><span class="line">   <span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(__x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>其中_M_insert_aux的实现为<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">    <span class="keyword">void</span></span><br><span class="line">    vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line">    _M_insert_aux(iterator __position, _Args&amp;&amp;... __args)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">  <span class="keyword">void</span></span><br><span class="line">  vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line">  _M_insert_aux(iterator __position, <span class="keyword">const</span> _Tp&amp; __x)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_M_impl._M_finish != <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage)&#123;</span><br><span class="line">      <span class="comment">// 一.这个分支是可用空间未满的情况</span></span><br><span class="line">      <span class="comment">// push_back不会走这个分支，因为在调用这个函数前已经做过判断了，insert调用时可能会走这个分支</span></span><br><span class="line">      <span class="comment">// 1._M_finish位置上的元素使用_M_finish-1位置上的对象并将_M_finish指针后移一位，会调用一次移动构造或者拷贝构造</span></span><br><span class="line">  	  _Alloc_traits::<span class="built_in">construct</span>(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">  			           _GLIBCXX_MOVE(*(<span class="keyword">this</span>-&gt;_M_impl._M_finish</span><br><span class="line">  				                   - <span class="number">1</span>)));</span><br><span class="line">  	  ++<span class="keyword">this</span>-&gt;_M_impl._M_finish;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> __cplusplus &lt; 201103L</span></span><br><span class="line">  	  _Tp __x_copy = __x;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="comment">// 2.将元素从[__position, _M_finish - 2) 范围移动到另一个以_M_finish - 1结尾(不包括_M_finish - 1，其在上一步已经move了)的范围。</span></span><br><span class="line">      <span class="comment">// 元素以相反的顺序移动（最后一个元素首先移动），但是保留了它们的相对顺序</span></span><br><span class="line">  	  _GLIBCXX_MOVE_BACKWARD3(__position.<span class="built_in">base</span>(),</span><br><span class="line">  				  <span class="keyword">this</span>-&gt;_M_impl._M_finish - <span class="number">2</span>,</span><br><span class="line">  				  <span class="keyword">this</span>-&gt;_M_impl._M_finish - <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 3.将__position位置的元素置为x</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> __cplusplus &lt; 201103L</span></span><br><span class="line">  	  *__position = __x_copy;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="comment">// 这里会调用一次构造函数（移动或者拷贝）+ 一次赋值函数（移动或者拷贝）+ 一次析构函数</span></span><br><span class="line">  	  *__position = _Tp(std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 二.这个分支是可用空间已満的情况</span></span><br><span class="line">      <span class="comment">// 1.计算重新分配所需要的空间</span></span><br><span class="line">      <span class="comment">// _M_check_len在传入参数为1的情况下，只要没有超出stl规定的最大内存大小，每次返回当前容器大小的双倍，初次返回1</span></span><br><span class="line">  	  <span class="keyword">const</span> size_type __len =</span><br><span class="line">  	    _M_check_len(<span class="built_in">size_type</span>(<span class="number">1</span>), <span class="string">&quot;vector::_M_insert_aux&quot;</span>);</span><br><span class="line">  	  <span class="keyword">const</span> size_type __elems_before = __position - <span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.重新分配一块长度为__len的内存</span></span><br><span class="line">  	  pointer __new_start(<span class="keyword">this</span>-&gt;_M_allocate(__len));</span><br><span class="line">  	  pointer __new_finish(__new_start);</span><br><span class="line">  	  __try&#123;</span><br><span class="line">  	      <span class="comment">// The order of the three operations is dictated by the C++0x</span></span><br><span class="line">  	      <span class="comment">// case, where the moves could alter a new element belonging</span></span><br><span class="line">  	      <span class="comment">// to the existing vector.  This is an issue only for callers</span></span><br><span class="line">  	      <span class="comment">// taking the element by const lvalue ref (see 23.1/13).</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 3.在要插入的位置构造新对象，调用拷贝构造或者移动构造函数</span></span><br><span class="line">          _Alloc_traits::<span class="built_in">construct</span>(<span class="keyword">this</span>-&gt;_M_impl,</span><br><span class="line">  		                       __new_start + __elems_before,</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">  				       std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  	                               __x);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          __new_finish = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 4.将__position之前的元素拷贝或者移动构造到新的内存空间</span></span><br><span class="line">          <span class="comment">// 这个函数根据容器中存储的对象的movable以及copyable性质，使用移动构造或者拷贝构造函数在新分配的内存上构造对象</span></span><br><span class="line">          <span class="comment">// 对这个函数的具体拆解分析见https://www.codeleading.com/article/16845903587/</span></span><br><span class="line">          <span class="comment">// 结论：如果一个类，不存在不会抛出异常的移动构造函数并且可拷贝，那么就调用拷贝构造函数，否则调用移动构造函数</span></span><br><span class="line">          <span class="comment">// 这一点提醒我们类的移动构造和移动赋值函数添加noexcept关键字可以提高在容器中使用的效率</span></span><br><span class="line">  	      __new_finish</span><br><span class="line">        		= std::__uninitialized_move_if_noexcept_a</span><br><span class="line">        		(<span class="keyword">this</span>-&gt;_M_impl._M_start, __position.<span class="built_in">base</span>(),</span><br><span class="line">        		 __new_start, _M_get_Tp_allocator());</span><br><span class="line"></span><br><span class="line">  	      ++__new_finish;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 5.将__position位置之后的元素也拷贝或者移动构造到新的位置，这个会在insert的情景下使用</span></span><br><span class="line">  	      __new_finish</span><br><span class="line">        		= std::__uninitialized_move_if_noexcept_a</span><br><span class="line">        		(__position.<span class="built_in">base</span>(), <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">        		 __new_finish, _M_get_Tp_allocator());</span><br><span class="line">	    &#125;</span><br><span class="line">      __catch(...)&#123;</span><br><span class="line">  	      <span class="keyword">if</span> (!__new_finish)</span><br><span class="line">  		      _Alloc_traits::<span class="built_in">destroy</span>(<span class="keyword">this</span>-&gt;_M_impl,</span><br><span class="line">  		                       __new_start + __elems_before);</span><br><span class="line">  	      <span class="keyword">else</span></span><br><span class="line">  		      std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());</span><br><span class="line">  	         _M_deallocate(__new_start, __len);</span><br><span class="line">  	           __throw_exception_again;</span><br><span class="line">  	  &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 三.构造旧的对象并释放空间，同时更新vector的三个指针</span></span><br><span class="line">  	  std::_Destroy(<span class="keyword">this</span>-&gt;_M_impl._M_start, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">  			   _M_get_Tp_allocator());</span><br><span class="line">  	  _M_deallocate(<span class="keyword">this</span>-&gt;_M_impl._M_start,</span><br><span class="line">    			<span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage</span><br><span class="line">    			- <span class="keyword">this</span>-&gt;_M_impl._M_start);</span><br><span class="line">  	  <span class="keyword">this</span>-&gt;_M_impl._M_start = __new_start;</span><br><span class="line">  	  <span class="keyword">this</span>-&gt;_M_impl._M_finish = __new_finish;</span><br><span class="line">  	  <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage = __new_start + __len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>其中确定新的内存空间大小的函数_M_len的实现如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">size_type _M_check_len(size_type __n, <span class="keyword">const</span> <span class="keyword">char</span>* __s) <span class="keyword">const</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">max_size</span>() - <span class="built_in">size</span>() &lt; __n)</span><br><span class="line">    __throw_length_error(__N(__s));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> size_type __len = <span class="built_in">size</span>() + std::<span class="built_in">max</span>(<span class="built_in">size</span>(), __n);</span><br><span class="line">  <span class="keyword">return</span> (__len &lt; <span class="built_in">size</span>() || __len &gt; <span class="built_in">max_size</span>()) ? <span class="built_in">max_size</span>() : __len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="均摊时间复杂度分析"><a href="#均摊时间复杂度分析" class="headerlink" title="均摊时间复杂度分析"></a>均摊时间复杂度分析</h3><p>经过上述分析，知道push_back时的开销主要分为两部分（下面的分析以调用拷贝构造函数为例）</p>
<ul>
<li><p>当可用空间已満时，此时需要调用一次拷贝构造函数构造新增加的对象，然后调用$2^k$次拷贝构造函数将旧的数据移动到新的内存空间中，因此这种情况下的开销是$1+2^k$；</p>
</li>
<li><p>如果可用空间未満，此时只需要调用一次拷贝构造函数即可</p>
</li>
</ul>
<p>依照下图的分析与示例推导vector的时间复杂度的表达式</p>
<div align="center">
<img src="/all_images/vector知识点整理/4.png">
</div>

<div align="center">
<img src="/all_images/vector知识点整理/3.png">
</div>

<p>假设总共调用了$n$次push_back，共经过$k$次扩容，那么可以得到<br>\begin{align}<br>1+2+…+2^k &amp;\ge n \\<br>\frac{2^{k+1}-1}{2-1} &amp;\ge n\\<br> k &amp;\ge \log_{2}{(n+1)}-1\\<br> k &amp;\approx \log_{2}{n}<br>\end{align}</p>
<p>因此，$n$次push_back总的开销为<br>\begin{align}<br>1+2+…+2^k + n &amp;= 2^{k+1}-1+n \\<br>&amp;=2\cdot 2^k+n-1 \\<br>&amp;=3n-1<br>\end{align}</p>
<p>所以，均摊的时间复杂度为<br>\begin{align}<br>\frac{3n-1}{n}= 3<br>\end{align}</p>
<p>即均摊的时间复杂度为O(1)</p>
<h2 id="emplace-back"><a href="#emplace-back" class="headerlink" title="emplace_back"></a>emplace_back</h2><p>emplace_back是C++11后新增加的在vector尾部增加元素的函数，它和push_back的区别在于底层实现的机制不同。push_back向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而emplace_back则是<strong>直接在容器尾部创建这个元素</strong>，省去了拷贝或移动元素的过程，此外如果添加的元素是一个右值，新构造对象时会调用<strong>移动构造函数而不是拷贝构造函数</strong></p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">    <span class="keyword">void</span> vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line">    <span class="built_in">emplace_back</span>(_Args&amp;&amp;... __args)&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_M_impl._M_finish != <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage)&#123;</span><br><span class="line">          _Alloc_traits::<span class="built_in">construct</span>(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">                 std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">          ++<span class="keyword">this</span>-&gt;_M_impl._M_finish;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        _M_emplace_back_aux(std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果空间未满，emplace_back直接使用完美转发机制在_M_finish的位置原地构造新对象，并将_M_finish指针向后移动一位，如果已分配的空间已满，则调用辅助函数_M_emplace_back_aux，其实现如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">    <span class="keyword">void</span> vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line">    _M_emplace_back_aux(_Args&amp;&amp;... __args)&#123;</span><br><span class="line">      <span class="comment">// 1.与_M_insert_aux相同，都是将空间大小翻倍</span></span><br><span class="line">      <span class="keyword">const</span> size_type __len =</span><br><span class="line">          _M_check_len(<span class="built_in">size_type</span>(<span class="number">1</span>), <span class="string">&quot;vector::_M_emplace_back_aux&quot;</span>);</span><br><span class="line">      pointer __new_start(<span class="keyword">this</span>-&gt;_M_allocate(__len));</span><br><span class="line">      pointer __new_finish(__new_start);</span><br><span class="line">      __try&#123;</span><br><span class="line">        <span class="comment">// 2.在新分配的空间上构造对象</span></span><br><span class="line">        _Alloc_traits::<span class="built_in">construct</span>(<span class="keyword">this</span>-&gt;_M_impl, __new_start + <span class="built_in">size</span>(),</span><br><span class="line">               std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">        __new_finish = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.将[_M_start, _M_finish)移动或者拷贝到新的内存空间</span></span><br><span class="line">        __new_finish</span><br><span class="line">          = std::__uninitialized_move_if_noexcept_a</span><br><span class="line">          (<span class="keyword">this</span>-&gt;_M_impl._M_start, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">           __new_start, _M_get_Tp_allocator());</span><br><span class="line"></span><br><span class="line">        ++__new_finish;</span><br><span class="line">      &#125;</span><br><span class="line">      __catch(...)&#123;</span><br><span class="line">          <span class="keyword">if</span> (!__new_finish)</span><br><span class="line">            _Alloc_traits::<span class="built_in">destroy</span>(<span class="keyword">this</span>-&gt;_M_impl, __new_start + <span class="built_in">size</span>());</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());</span><br><span class="line">            _M_deallocate(__new_start, __len);</span><br><span class="line">            __throw_exception_again;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="number">4.</span>析构旧的对象并释放空间</span><br><span class="line">      std::_Destroy(<span class="keyword">this</span>-&gt;_M_impl._M_start, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">              _M_get_Tp_allocator());</span><br><span class="line">      _M_deallocate(<span class="keyword">this</span>-&gt;_M_impl._M_start,</span><br><span class="line">              <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage</span><br><span class="line">              - <span class="keyword">this</span>-&gt;_M_impl._M_start);</span><br><span class="line">      <span class="keyword">this</span>-&gt;_M_impl._M_start = __new_start;</span><br><span class="line">      <span class="keyword">this</span>-&gt;_M_impl._M_finish = __new_finish;</span><br><span class="line">      <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage = __new_start + __len;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p>insert有多个版本的重载函数，较常使用的是在指定位置pos位插入元素，实现主要分为两种情况</p>
<ul>
<li><p>如果可用空间已満：</p>
<ul>
<li><p>先分配一块二倍于原来内存的空间，然后调用拷贝构造函数在新空间对应位置pos处构造新元素</p>
</li>
<li><p>将旧空间内pos<strong>之前以及之后</strong>的元素<strong>拷贝或者移动构</strong>造到新的内存空间</p>
</li>
<li><p>析构旧的空间上的对象</p>
</li>
</ul>
</li>
<li><p>如果可用空间未満：</p>
<ul>
<li><p>先拷贝构造一个局部对象，然后调用一次<strong>拷贝构造或者移动构造函数</strong>，将原空间中的最后一个元素向后移动一位</p>
</li>
<li><p>调用移动赋值或者拷贝赋值函数，将pos位置之后的元素（除了最后一位）依次向后移动一位</p>
</li>
<li><p>使用移动构造函数构造一个临时对象并调用移动赋值或者拷贝赋值函数将这个临时对象拷贝或者移动到pos的位置处：对应代码为*<strong>position = _Tp(std::forward<_Args>(</strong>args)…);</p>
</li>
</ul>
</li>
</ul>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">  <span class="keyword">typename</span> vector&lt;_Tp, _Alloc&gt;::iterator</span><br><span class="line">  vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">  <span class="built_in">insert</span>(const_iterator __position, <span class="keyword">const</span> value_type&amp; __x)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="built_in">insert</span>(iterator __position, <span class="keyword">const</span> value_type&amp; __x)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> size_type __n = __position - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// 一.如果要插入的位置是_M_finish且内存空间未満，则直接在_M_finish处构造对象即可（调用拷贝构造函数）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_M_impl._M_finish != <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage</span><br><span class="line">        &amp;&amp; __position == <span class="built_in">end</span>())&#123;</span><br><span class="line">        _Alloc_traits::<span class="built_in">construct</span>(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish, __x);</span><br><span class="line">        ++<span class="keyword">this</span>-&gt;_M_impl._M_finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> __pos = <span class="built_in">begin</span>() + (__position - <span class="built_in">cbegin</span>());</span><br><span class="line">      <span class="comment">// 二.调用_M_insert_aux，这个函数的实现在上文push_back那一小节，如果已分配的空间已满，则传入左值，未満时传入拷贝对象的右值引用(不太懂这里为什么这样做，</span></span><br><span class="line">      <span class="comment">// 拷贝一个对象并传入右值引用，然后使用移动构造函数构造新对象，那为什么不像另一种情况一样都一直调用拷贝构造呢？)</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_M_impl._M_finish != <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage)&#123;</span><br><span class="line">          <span class="comment">// 调用一次拷贝构造函数+一次析构函数</span></span><br><span class="line">          _Tp __x_copy = __x;</span><br><span class="line">          _M_insert_aux(__pos, std::<span class="built_in">move</span>(__x_copy));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        _M_insert_aux(__pos, __x);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      _M_insert_aux(__position, __x);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>-&gt;_M_impl._M_start + __n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">X</span>():<span class="built_in">b</span>(<span class="number">0</span>) &#123;cout &lt;&lt; <span class="string">&quot;调用构造函数：X()&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">int</span> a): <span class="built_in">b</span>(a)&#123;cout &lt;&lt; <span class="string">&quot;调用构造函数：X(int a)&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">const</span> X&amp; x): <span class="built_in">b</span>(x.b)&#123;cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数：X(const X&amp;)&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span>: <span class="built_in">b</span>(a.b)  &#123;cout &lt;&lt; <span class="string">&quot;调用移动构造函数：X(X&amp;&amp; a) noexcept &quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    X&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> X&amp; a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;b = a.b;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用拷贝赋值函数：X&amp; operator = (const X&amp; a)  &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;b = a.b;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用移动赋值函数：X&amp; operator = (X&amp;&amp; a)  noexcept  &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">X</span>()&#123;cout &lt;&lt; <span class="string">&quot;调用析构函数：~X()&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    std::vector&lt;X&gt; vec;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;存放在容器：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;加入 &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        vec.<span class="built_in">insert</span>(it, <span class="built_in">X</span>(i));</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;程序结束！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的输出结果如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">存放在容器：</span><br><span class="line">加入 <span class="number">0</span></span><br><span class="line">调用构造函数：<span class="built_in">X</span>(<span class="keyword">int</span> a)</span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line"></span><br><span class="line">加入 <span class="number">1</span></span><br><span class="line">调用构造函数：<span class="built_in">X</span>(<span class="keyword">int</span> a)</span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line"></span><br><span class="line">加入 <span class="number">2</span></span><br><span class="line">调用构造函数：<span class="built_in">X</span>(<span class="keyword">int</span> a)</span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line"></span><br><span class="line">加入 <span class="number">3</span></span><br><span class="line">调用构造函数：<span class="built_in">X</span>(<span class="keyword">int</span> a)</span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line"></span><br><span class="line">加入 <span class="number">4</span></span><br><span class="line">调用构造函数：<span class="built_in">X</span>(<span class="keyword">int</span> a)</span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line"></span><br><span class="line">加入 <span class="number">5</span></span><br><span class="line">调用构造函数：<span class="built_in">X</span>(<span class="keyword">int</span> a)</span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line"></span><br><span class="line">加入 <span class="number">6</span></span><br><span class="line">调用构造函数：<span class="built_in">X</span>(<span class="keyword">int</span> a)</span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line"></span><br><span class="line">加入 <span class="number">7</span></span><br><span class="line">调用构造函数：<span class="built_in">X</span>(<span class="keyword">int</span> a)</span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动赋值函数：X&amp; <span class="keyword">operator</span> = (X&amp;&amp; a)  <span class="keyword">noexcept</span>  </span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line"></span><br><span class="line">程序结束！！！</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br></pre></td></tr></table></figure></p>
<h2 id="emplace"><a href="#emplace" class="headerlink" title="emplace"></a>emplace</h2><p>emplace与insert的关系正如emplace_back与push_back的关系</p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">    <span class="keyword">typename</span> vector&lt;_Tp, _Alloc&gt;::iterator</span><br><span class="line">    vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line">    <span class="built_in">emplace</span>(const_iterator __position, _Args&amp;&amp;... __args)&#123;</span><br><span class="line">      <span class="keyword">const</span> size_type __n = __position - <span class="built_in">begin</span>();</span><br><span class="line">      <span class="comment">// 1.如果已分配的空间未满且插入的位置是_M_finish，则直接在_M_finish处构造对象即可</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_M_impl._M_finish != <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage</span><br><span class="line">          &amp;&amp; __position == <span class="built_in">end</span>())&#123;</span><br><span class="line">          _Alloc_traits::<span class="built_in">construct</span>(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">                 std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">          ++<span class="keyword">this</span>-&gt;_M_impl._M_finish;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 2.如果已分配的空间已满，则调用辅助函数_M_insert_aux， 这个函数的实现在上文push_back那一小节</span></span><br><span class="line">        _M_insert_aux(<span class="built_in">begin</span>() + (__position - <span class="built_in">cbegin</span>()),</span><br><span class="line">            std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">      <span class="comment">// 3.返回对应位置的指针</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>-&gt;_M_impl._M_start + __n);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><p>vector删除元素主要有两个函数：pop_back以及erase，二者只会析构部分对象，而<strong>不会释放现有已经申请的动态内存</strong></p>
<h2 id="pop-back"><a href="#pop-back" class="headerlink" title="pop_back"></a>pop_back</h2><p>pop_back的功能是移除vector中的末尾元素，实现比较简单，分为_M_finish指针自减一并析构最后一个元素两步</p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pop_back</span>() _GLIBCXX_NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">--<span class="keyword">this</span>-&gt;_M_impl._M_finish;</span><br><span class="line">_Alloc_traits::<span class="built_in">destroy</span>(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h2><p>erase有两个常用的版本，功能是在移除vector中的元素</p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除position位置处的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator __position)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _M_erase(<span class="built_in">begin</span>() + (__position - <span class="built_in">cbegin</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除[fisrt, last)中的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator __first, const_iterator __last)</span></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">auto</span> __beg = <span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">auto</span> __cbeg = <span class="built_in">cbegin</span>();</span><br><span class="line">	<span class="keyword">return</span> _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中调用的辅助函数_M_erase的两个重载函数实现如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将pos后的元素依次向前拷贝或者移动一位，然后析构掉最后一个对象;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">  <span class="keyword">typename</span> vector&lt;_Tp, _Alloc&gt;::iterator</span><br><span class="line">  vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line">  _M_erase(iterator __position)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (__position + <span class="number">1</span> != <span class="built_in">end</span>())</span><br><span class="line">_GLIBCXX_MOVE3(__position + <span class="number">1</span>, <span class="built_in">end</span>(), __position);</span><br><span class="line">    --<span class="keyword">this</span>-&gt;_M_impl._M_finish;</span><br><span class="line">    _Alloc_traits::<span class="built_in">destroy</span>(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish);</span><br><span class="line">    <span class="keyword">return</span> __position;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将[last, end)的元素移动到以first为开头的位置处，然后析构掉__first.base() + (end() - __last)之后的对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">  <span class="keyword">typename</span> vector&lt;_Tp, _Alloc&gt;::iterator</span><br><span class="line">  vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line">  _M_erase(iterator __first, iterator __last)&#123;</span><br><span class="line">    <span class="keyword">if</span> (__first != __last)&#123;</span><br><span class="line">      <span class="keyword">if</span> (__last != <span class="built_in">end</span>())</span><br><span class="line">        _GLIBCXX_MOVE3(__last, <span class="built_in">end</span>(), __first);</span><br><span class="line">      _M_erase_at_end(__first.<span class="built_in">base</span>() + (<span class="built_in">end</span>() - __last));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT&#123;</span><br><span class="line">    std::_Destroy(__pos, <span class="keyword">this</span>-&gt;_M_impl._M_finish, _M_get_Tp_allocator());</span><br><span class="line">    <span class="keyword">this</span>-&gt;_M_impl._M_finish = __pos;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>C++11前以及之后vector的迭代器的形式稍有不同， 但是本质都是一样的，都是<strong>value_type*</strong></p>
<h2 id="C-11前vector迭代器的实现"><a href="#C-11前vector迭代器的实现" class="headerlink" title="C++11前vector迭代器的实现"></a>C++11前vector迭代器的实现</h2><p>C++11前vector的实现比较直观明了，直接定义为value_type*，当需要获取迭代器的内部特性时，使用的是偏特化版本的iterator_traits</p>
<div align="center">
<img src="/all_images/vector知识点整理/5.png">
</div>

<h2 id="C-11后vector迭代器的实现"><a href="#C-11后vector迭代器的实现" class="headerlink" title="C++11后vector迭代器的实现"></a>C++11后vector迭代器的实现</h2><p>如前文所述，C++11对vector类的继承关系进行了调整，同时也修改了迭代器的实现方式（如下)，当需要获取迭代器的内部特性时，使用的是普通版本的iterator_traits</p>
<p><div align="center">
<img src="/all_images/vector知识点整理/6.png">
</div></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="reserve"><a href="#reserve" class="headerlink" title="reserve"></a>reserve</h2><p>reserve的作用是为vector预先分配指定大小的内存空间，来减少push_back以及insert过程中遇到分配内存已満要多次拷贝或者移动对象的开销</p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">    <span class="keyword">void</span> vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line">    <span class="built_in">reserve</span>(size_type __n)&#123;</span><br><span class="line">      <span class="keyword">if</span> (__n &gt; <span class="keyword">this</span>-&gt;<span class="built_in">max_size</span>())</span><br><span class="line">	     __throw_length_error(__N(<span class="string">&quot;vector::reserve&quot;</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 只有当前的容量小于reserve的大小时才发生内存的分配</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">capacity</span>() &lt; __n)&#123;</span><br><span class="line">      	  <span class="keyword">const</span> size_type __old_size = <span class="built_in">size</span>();</span><br><span class="line">          <span class="comment">// 1.调用移动构造或者拷贝构造搬移对象</span></span><br><span class="line">      	  pointer __tmp = _M_allocate_and_copy(__n,</span><br><span class="line">    	       _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(<span class="keyword">this</span>-&gt;_M_impl._M_start),</span><br><span class="line">    	        _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(<span class="keyword">this</span>-&gt;_M_impl._M_finish));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 2.析构旧的空间上的对象并回收内存</span></span><br><span class="line">          std::_Destroy(<span class="keyword">this</span>-&gt;_M_impl._M_start, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">      			   _M_get_Tp_allocator());</span><br><span class="line">      	  _M_deallocate(<span class="keyword">this</span>-&gt;_M_impl._M_start,</span><br><span class="line">        			<span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage</span><br><span class="line">        			- <span class="keyword">this</span>-&gt;_M_impl._M_start);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 3.更新三个指针</span></span><br><span class="line">      	  <span class="keyword">this</span>-&gt;_M_impl._M_start = __tmp;</span><br><span class="line">      	  <span class="keyword">this</span>-&gt;_M_impl._M_finish = __tmp + __old_size;</span><br><span class="line">      	  <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage = <span class="keyword">this</span>-&gt;_M_impl._M_start + __n;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下示例为了验证vector在reserve过程中确实发生的对象的拷贝或移动<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    std::vector&lt;X&gt; vec;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;存放在容器：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;加入 &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">X</span>(i));</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity before is &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size before is &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity after is &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size after is &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;程序结束！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">capacity before is <span class="number">4</span></span><br><span class="line">size before is <span class="number">4</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">capacity after is <span class="number">10</span></span><br><span class="line">size after is <span class="number">4</span></span><br><span class="line">程序结束！！！</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br></pre></td></tr></table></figure></p>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><p>resize用于调整vector现有的元素的数量，值得注意的是如果<strong>新增的元素的数量<strong>n大于原来的元素数量size()，那么就分配size()+</strong>n的新空间，否则分配2倍的size()大小的空间</strong>。其实就是如果双倍内存可以满足要求就申请一块双倍的内存，否则就要多少内存给多少内存</p>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type __new_size)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 1.如果__new_size大于原来的size，则向vector中添加_new_size-size()个默认构造的对象</span></span><br><span class="line">  <span class="keyword">if</span> (__new_size &gt; <span class="built_in">size</span>())</span><br><span class="line">    _M_default_append(__new_size - <span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (__new_size &lt; <span class="built_in">size</span>())</span><br><span class="line">    <span class="comment">// 2.如果__new_size小于原来的size，就将_M_start+__new_size后的对象都析构掉</span></span><br><span class="line">    _M_erase_at_end(<span class="keyword">this</span>-&gt;_M_impl._M_start + __new_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">    <span class="keyword">void</span> vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line">    _M_default_append(size_type __n)&#123;</span><br><span class="line">      <span class="keyword">if</span> (__n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 一.如果可用空间足够大，直接从_M_finish开始构造__n个默认对象</span></span><br><span class="line">    	  <span class="keyword">if</span> (<span class="built_in">size_type</span>(<span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage</span><br><span class="line">    			- <span class="keyword">this</span>-&gt;_M_impl._M_finish) &gt;= __n)&#123;</span><br><span class="line">    	      <span class="keyword">this</span>-&gt;_M_impl._M_finish =</span><br><span class="line">            		std::__uninitialized_default_n_a(<span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">            						 __n, _M_get_Tp_allocator());</span><br><span class="line">  	    &#125;</span><br><span class="line">    	  <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 二.可用空间不足__n的情况</span></span><br><span class="line">            <span class="comment">// 1.如果新增的元素的数量__n大于原来的元素数量size()，那么就分配size()+__n的新空间，否则分配2倍的size()大小的空间</span></span><br><span class="line">    	      <span class="keyword">const</span> size_type __len =</span><br><span class="line">    		        _M_check_len(__n, <span class="string">&quot;vector::_M_default_append&quot;</span>);</span><br><span class="line">    	      <span class="keyword">const</span> size_type __old_size = <span class="keyword">this</span>-&gt;<span class="built_in">size</span>();</span><br><span class="line">    	      pointer __new_start(<span class="keyword">this</span>-&gt;_M_allocate(__len));</span><br><span class="line">    	      pointer __new_finish(__new_start);</span><br><span class="line">    	      __try&#123;</span><br><span class="line">              <span class="comment">// 2.调用移动构造或者拷贝构造函数搬移旧对象</span></span><br><span class="line">        		  __new_finish</span><br><span class="line">        		    = std::__uninitialized_move_if_noexcept_a</span><br><span class="line">        		      (<span class="keyword">this</span>-&gt;_M_impl._M_start, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">        		          __new_start, _M_get_Tp_allocator());</span><br><span class="line">              <span class="comment">// 3.在新的内存空间中构造__n个默认对象</span></span><br><span class="line">        		  __new_finish =</span><br><span class="line">        		    std::__uninitialized_default_n_a(__new_finish, __n,</span><br><span class="line">        						     _M_get_Tp_allocator());</span><br><span class="line">           &#125;</span><br><span class="line">    	      __catch(...)&#123;</span><br><span class="line">        		  std::_Destroy(__new_start, __new_finish,</span><br><span class="line">        				_M_get_Tp_allocator());</span><br><span class="line">        		  _M_deallocate(__new_start, __len);</span><br><span class="line">        		  __throw_exception_again;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 4.析构旧的空间上的对象并回收内存</span></span><br><span class="line">    	      std::_Destroy(<span class="keyword">this</span>-&gt;_M_impl._M_start, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">    			       _M_get_Tp_allocator());</span><br><span class="line">    	      _M_deallocate(<span class="keyword">this</span>-&gt;_M_impl._M_start,</span><br><span class="line">      			    <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage</span><br><span class="line">      			    - <span class="keyword">this</span>-&gt;_M_impl._M_start);</span><br><span class="line">            <span class="comment">// 5.更新3个指针</span></span><br><span class="line">    	      <span class="keyword">this</span>-&gt;_M_impl._M_start = __new_start;</span><br><span class="line">    	      <span class="keyword">this</span>-&gt;_M_impl._M_finish = __new_finish;</span><br><span class="line">    	      <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage = __new_start + __len;</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    std::vector&lt;X&gt; vec;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;存放在容器：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;加入 &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">X</span>(i));</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity before is &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size before is &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    vec.resize(6);</span></span><br><span class="line">    vec.<span class="built_in">resize</span>(<span class="number">9</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity after is &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size after is &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;程序结束！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的输出结果如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">capacity before is <span class="number">4</span></span><br><span class="line">size before is <span class="number">4</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用构造函数：<span class="built_in">X</span>()</span><br><span class="line">调用构造函数：<span class="built_in">X</span>()</span><br><span class="line">调用构造函数：<span class="built_in">X</span>()</span><br><span class="line">调用构造函数：<span class="built_in">X</span>()</span><br><span class="line">调用构造函数：<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">capacity after is <span class="number">9</span></span><br><span class="line">size after is <span class="number">9</span></span><br><span class="line">程序结束！！！</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br></pre></td></tr></table></figure></p>
<h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>clear其实是一个特殊的erase，其erase了vector中的所有对象，但是并没有释放其已有的内存。</p>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> _GLIBCXX_NOEXCEPT</span>&#123;</span><br><span class="line">   _M_erase_at_end(<span class="keyword">this</span>-&gt;_M_impl._M_start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><p>vector的swap只是将指针而已进行交换，也就是空间的交换实际是指针的交换，因此效率比较高</p>
<h3 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(vector&amp; __x)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus &gt;= 201103L</span></span></span><br><span class="line"><span class="function">  <span class="title">noexcept</span><span class="params">(_Alloc_traits::_S_nothrow_swap())</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;_M_impl._M_swap_data(__x._M_impl);</span><br><span class="line">  _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),</span><br><span class="line">                      __x._M_get_Tp_allocator());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _M_swap_data(_Vector_impl&amp; __x) _GLIBCXX_NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">  std::<span class="built_in">swap</span>(_M_start, __x._M_start);</span><br><span class="line">  std::<span class="built_in">swap</span>(_M_finish, __x._M_finish);</span><br><span class="line">  std::<span class="built_in">swap</span>(_M_end_of_storage, __x._M_end_of_storage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用技巧：swap用于内存释放"><a href="#常用技巧：swap用于内存释放" class="headerlink" title="常用技巧：swap用于内存释放"></a>常用技巧：swap用于内存释放</h3><p>由上文对erase以及clear的分析可知，这两者只是析构了对应位置处的元素，并不会回收对应的内存，而要想回收已经分配给vector的内存，需要借助swap或者下文的shrink_to_fit来减少vector占用的内存。通过如下代码即可释放容器X的所占用的内存<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放全部内存</span></span><br><span class="line">vector&lt;T&gt;().<span class="built_in">swap</span>(X)</span><br><span class="line"><span class="comment">// 释放没有所有的内存，等价于shrink_to_fit  </span></span><br><span class="line">vector&lt;T&gt;(X).<span class="built_in">swap</span>(X)</span><br></pre></td></tr></table></figure></p>
<p>但是反之下面的代码是错误的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X.<span class="built_in">swap</span>(std::vector&lt;T&gt;())</span><br></pre></td></tr></table></figure><br>原因在于swap的形参为左值引用，而这种情况下实参是一个右值，C++并不支持将一个左值引用绑定到右值上，因此上面的做法是错误的</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    std::vector&lt;X&gt; vec;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;存放在容器：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;加入 &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">X</span>(i));</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity before is &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size before is &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;X&gt;().<span class="built_in">swap</span>(vec);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity after is &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size after is &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;程序结束！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">capacity before is <span class="number">4</span></span><br><span class="line">size before is <span class="number">4</span></span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">capacity after is <span class="number">0</span></span><br><span class="line">size after is <span class="number">0</span></span><br><span class="line">程序结束！！！</span><br></pre></td></tr></table></figure></p>
<h2 id="shrink-to-fit"><a href="#shrink-to-fit" class="headerlink" title="shrink_to_fit"></a>shrink_to_fit</h2><p>shrink_to_fit是C++11中新增加的函数，作用是将容量减少至它现在需要的容量，这样减少容量的方法被称为”收缩到合适（shrink to fit）”。cplusplus官方文档中对于shrink_to_fit的描述如下</p>
<blockquote>
<p>The request is non-binding, and the container implementation is free to optimize otherwise and leave the vector with a capacity greater than its size.<br>This may cause a reallocation, but has no effect on the vector size and cannot alter its elements.</p>
</blockquote>
<p>即回收_M_finish和_M_end_of_storage之间的内存这个请求是<strong>非约束性的</strong>(non-binding)，具体的实现由编译器来实现。下文中贴出的gcc4.9中的实现满足了这个约束且<strong>重新分配了内存空间并析构了原来的内存上的对象</strong>，这样重新分配空间后，原来的迭代器就会失效。通过下面的代码可以发现shrink_to_fit的核心还是使用了swap释放内存的技巧</p>
<h3 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  A non-binding request to reduce capacity() to size().  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shrink_to_fit</span><span class="params">()</span></span>&#123;</span><br><span class="line">  _M_shrink_to_fit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line">  <span class="keyword">bool</span> vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line">  _M_shrink_to_fit()&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">capacity</span>() == <span class="built_in">size</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> std::__shrink_to_fit_aux&lt;vector&gt;::_S_do_it(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">bool</span></span><br><span class="line">  = __or_&lt;is_copy_constructible&lt;<span class="keyword">typename</span> _Tp::value_type&gt;,</span><br><span class="line">          is_nothrow_move_constructible&lt;<span class="keyword">typename</span> _Tp::value_type&gt;&gt;::value&gt;</span><br><span class="line">  struct __shrink_to_fit_aux</span><br><span class="line">  &#123; <span class="keyword">static</span> <span class="keyword">bool</span> _S_do_it(_Tp&amp;) <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">shrink_to_fit_aux</span>&lt;</span>_Tp, <span class="literal">true</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> _S_do_it(_Tp&amp; __c) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">      __try&#123;</span><br><span class="line">        <span class="comment">// swap用于内存释放的技巧，会调用移动构造函数或者拷贝构造函数以及析构函数</span></span><br><span class="line">        _Tp(__make_move_if_noexcept_iterator(__c.<span class="built_in">begin</span>()),</span><br><span class="line">            __make_move_if_noexcept_iterator(__c.<span class="built_in">end</span>()),</span><br><span class="line">            __c.<span class="built_in">get_allocator</span>()).<span class="built_in">swap</span>(__c);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      __catch(...)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    std::vector&lt;X&gt; vec;</span><br><span class="line">    std::list&lt;<span class="keyword">int</span>&gt; test_list;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;存放在容器：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;加入 &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">X</span>(i));</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity before is &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size before is &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vec.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity after is &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size after is &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;程序结束！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">capacity before is <span class="number">8</span></span><br><span class="line">size before is <span class="number">6</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用移动构造函数：<span class="built_in">X</span>(X&amp;&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">capacity after is <span class="number">6</span></span><br><span class="line">size after is <span class="number">6</span></span><br><span class="line">程序结束！！！</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br><span class="line">调用析构函数：~<span class="built_in">X</span>()</span><br></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/19PDP/Bilibili-plus">候捷STL</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1831752">三张图带你弄懂STL中内存分配器</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040103598">超详细STL之基于源码剖析vector实现原理及注意事项</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.codeleading.com/article/16845903587/">std::vector扩容时为何进行深复制？</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/CPlusPlusThings/ca7ffa122ab5f274.md">EBO优化</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14148756/what-does-template-rebind-do">what does (template) rebind&lt;&gt; do?</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/185611161">第10篇:C++ 堆内存管理器-allocator</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://people.engr.tamu.edu/andreas-klappenecker/csce411-s14/csce411-amortized2.pdf">Amortized Analysis of vector::push_back</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaobingqianrui/p/9092051.html">vector释放内存之swap方法 </a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/vector/vector/shrink_to_fit/">std::vector::shrink_to_fit</a></p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/STL/" rel="tag"># STL</a>
              <a href="/tags/vector/" rel="tag"># vector</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/16/%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/" rel="prev" title="对极几何">
      <i class="fa fa-chevron-left"></i> 对极几何
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/27/%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B5%E7%9A%84%E6%B1%82%E5%AF%BC/" rel="next" title="向量和矩阵的求导">
      向量和矩阵的求导 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vector%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.</span> <span class="nav-text">vector的底层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11%E5%89%8Dvector%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88gcc-2-9%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">C++11前vector的实现（gcc 2.9）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11%E5%90%8Evector%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88gcc-4-9%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">C++11后vector的实现（gcc 4.9）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="nav-number">3.</span> <span class="nav-text">增加元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#push-back"><span class="nav-number">3.1.</span> <span class="nav-text">push_back</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">3.1.1.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-number">3.1.2.</span> <span class="nav-text">均摊时间复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#emplace-back"><span class="nav-number">3.2.</span> <span class="nav-text">emplace_back</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">3.2.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#insert"><span class="nav-number">3.3.</span> <span class="nav-text">insert</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="nav-number">3.3.1.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">3.3.2.</span> <span class="nav-text">示例代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#emplace"><span class="nav-number">3.4.</span> <span class="nav-text">emplace</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="nav-number">3.4.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">4.</span> <span class="nav-text">删除元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pop-back"><span class="nav-number">4.1.</span> <span class="nav-text">pop_back</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="nav-number">4.1.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#erase"><span class="nav-number">4.2.</span> <span class="nav-text">erase</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6"><span class="nav-number">4.2.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11%E5%89%8Dvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.1.</span> <span class="nav-text">C++11前vector迭代器的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11%E5%90%8Evector%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.2.</span> <span class="nav-text">C++11后vector迭代器的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">6.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#reserve"><span class="nav-number">6.1.</span> <span class="nav-text">reserve</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-7"><span class="nav-number">6.1.1.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">6.1.2.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#resize"><span class="nav-number">6.2.</span> <span class="nav-text">resize</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-8"><span class="nav-number">6.2.1.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">6.2.2.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clear"><span class="nav-number">6.3.</span> <span class="nav-text">clear</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-9"><span class="nav-number">6.3.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#swap"><span class="nav-number">6.4.</span> <span class="nav-text">swap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-10"><span class="nav-number">6.4.1.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%9Aswap%E7%94%A8%E4%BA%8E%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE"><span class="nav-number">6.4.2.</span> <span class="nav-text">常用技巧：swap用于内存释放</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">6.4.2.1.</span> <span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shrink-to-fit"><span class="nav-number">6.5.</span> <span class="nav-text">shrink_to_fit</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-11"><span class="nav-number">6.5.1.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="nav-number">6.5.2.</span> <span class="nav-text">示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="vitalemonate"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">vitalemonate</p>
  <div class="site-description" itemprop="description">Ideas don't come out of thin air</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/vitalemonate" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;vitalemonate" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/952070377@qq.com" title="E-Mail → 952070377@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vitalemonate</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  











<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'WXYIx5XRBQI0dHgsV4ppd4xj-MdYXbMMI',
      appKey     : 'xufQBscNKTzWCqkruodkqjSd',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
